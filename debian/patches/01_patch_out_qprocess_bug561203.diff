From: Modestas Vainius <modax@debian.org>
Subject: Replace QProcess with standard POSIX calls
  This works around pthreads+fork() segfaults and hangs on hppa. See Bug
 #561203.
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=561203
Forwarded: not-needed

--- b/kde4automoc.cpp
+++ b/kde4automoc.cpp
@@ -29,7 +29,6 @@
 #include <QtCore/QFile>
 #include <QtCore/QFileInfo>
 #include <QtCore/QHash>
-#include <QtCore/QProcess>
 #include <QtCore/QQueue>
 #include <QtCore/QRegExp>
 #include <QtCore/QStringList>
@@ -39,6 +38,7 @@
 #include <sys/types.h>
 #include <time.h>
 #include <errno.h>
+#include <sys/wait.h>
 
 #ifdef Q_OS_WIN
 #include <windows.h>
@@ -64,14 +64,12 @@
         bool generateMoc(const QString &sourceFile, const QString &mocFileName);
         void printUsage(const QString &);
         void printVersion();
+        int executeCommand(const QString& command, const QStringList& args);
         void echoColor(const QString &msg)
         {
-            QProcess cmakeEcho;
-            cmakeEcho.setProcessChannelMode(QProcess::ForwardedChannels);
             QStringList args(cmakeEchoColorArgs);
             args << msg;
-            cmakeEcho.start(cmakeExecutable, args, QIODevice::NotOpen);
-            cmakeEcho.waitForFinished(-1);
+            executeCommand(cmakeExecutable, args);
         }
 
         QString builddir;
@@ -108,6 +106,38 @@
     }
 }
 
+int AutoMoc::executeCommand(const QString& command, const QStringList& args)
+{
+    pid_t pid = fork();
+    if (pid == -1) {
+        perror("automoc4: unable to fork");
+        return -1;
+    } else if (pid == 0) {
+        /* Child. Execute command. */
+        char** argv = (char**) ::malloc((args.count()+2) * sizeof(char*));
+        char* cmd = ::strdup(command.toLocal8Bit().constData());
+
+        argv[0] = cmd;
+        int i = 0;
+        foreach (QString arg, args) {
+            i++;
+            argv[i] = ::strdup(arg.toLocal8Bit().constData());
+        }
+        argv[i+1] = static_cast<char*>(0);
+        ::execvp(cmd, argv);
+        ::perror(QString("automoc4: unable to execute command %1").arg(cmd).toLocal8Bit().constData());
+        ::exit(-1);
+    } else {
+        /* Parent */
+        int status;
+        pid_t ret = ::waitpid(pid, &status, 0);
+        if (ret == pid && WIFEXITED(status)) {
+            return WEXITSTATUS(status);
+        }
+        return -1;
+    }
+}
+
 int main(int argc, char **argv)
 {
     QCoreApplication app(argc, argv);
@@ -569,8 +599,6 @@
             echoColor("Generating " + mocFileName);
         }
 
-        QProcess mocProc;
-        mocProc.setProcessChannelMode(QProcess::ForwardedChannels);
         QStringList args(mocIncludes + mocDefinitions);
 #ifdef Q_OS_WIN
         args << "-DWIN32";
@@ -580,21 +608,11 @@
         if (verbose) {
             cout << mocExe << " " << args.join(QLatin1String(" ")) << endl;
         }
-        mocProc.start(mocExe, args, QIODevice::NotOpen);
-        if (mocProc.waitForStarted()) {
-            const bool result = mocProc.waitForFinished(-1);
-            if (!result || mocProc.exitCode()) {
-                cerr << "automoc4: process for " << mocFilePath
-                     << " failed: " << mocProc.errorString() << endl;
-                cerr << "pid to wait for: " << mocProc.pid() << endl;
-                failed = true;
-                QFile::remove(mocFilePath);
-            }
-            return true;
-        } else {
-            cerr << "automoc4: process for " << mocFilePath << "failed to start: " 
-                 << mocProc.errorString() << endl;
+        if (int ret = executeCommand(mocExe, args)) {
+            cerr << "automoc4: process for " << mocFilePath << " failed with " << ret << endl;
             failed = true;
+            QFile::remove(mocFilePath);
+            return true;
         }
     }
     return false;
